let o=null;const r=new Set,f=()=>{o&&(r.forEach(e=>o?.unobserve(e)),r.clear());const a={threshold:.1,rootMargin:"0px 0px -50px 0px"};o=new IntersectionObserver(e=>{e.forEach(s=>{if(s.isIntersecting){setTimeout(()=>{s.target.classList.add("animated")},100);const i=s.target.querySelector(".stagger-container");i&&Array.from(i.children).forEach((m,h)=>{setTimeout(()=>{m.classList.add("animated")},200+h*100)})}})},a),document.querySelectorAll(".animate-on-scroll:not(.animated)").forEach(e=>{o?.observe(e),r.add(e)}),document.querySelectorAll(".stagger-container").forEach(e=>{Array.from(e.children).forEach((i,d)=>{i.style.transitionDelay=`${d*.15}s`}),r.has(e)||(o?.observe(e),r.add(e))}),document.querySelectorAll("section:not(#home)").forEach(e=>{!e.classList.contains("animate-on-scroll")&&!r.has(e)&&(e.classList.add("animate-on-scroll"),o?.observe(e),r.add(e))});const t=document.querySelector("#home");t&&setTimeout(()=>{t.classList.add("animated")},200)},g=(a,c=.1)=>{const l=Array.from(a.children);l.forEach((t,e)=>{t.style.opacity="0",t.style.transform="translateY(30px)",t.style.transition=`opacity 0.6s ease-out ${e*c}s, transform 0.6s ease-out ${e*c}s`});const n=new IntersectionObserver(t=>{t.forEach(e=>{e.isIntersecting&&(l.forEach(s=>{s.style.opacity="1",s.style.transform="translateY(0)"}),n.unobserve(e.target))})},{threshold:.1,rootMargin:"0px 0px -50px 0px"});return n.observe(a),()=>n.unobserve(a)};export{g as addStaggerAnimation,f as initScrollAnimations};
